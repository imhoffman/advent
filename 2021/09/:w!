
(require '[clojure.string :as str])
(require '[clojure.set :as set])


(def input
  (->> "puzzle.txt"
       slurp
       (#(str/split % #"\n") ,,)
       (map vec)
       (map (fn [row] (mapv #(Integer/parseInt (str %)) row)) ,,)
       (vec)))


(def nrows (count input))
(def ncols (count (input 0)))


(defn check-height [r c o]
  (let [curr ((input r) c)]
    (cond
      (= r 0)
      (cond
        (= c 0)
        (if (and (> ((input (inc r)) c) curr)
                 (> ((input r) (inc c)) curr))
          (assoc o (vector r c) curr)
          o)

        (= c (dec ncols))
        (if (and (> ((input (inc r)) c) curr)
                 (> ((input r) (dec c)) curr))
          (assoc o (vector r c) curr)
          o)

        :else
        (if (and (> ((input (inc r)) c) curr)
                 (> ((input r) (dec c)) curr)
                 (> ((input r) (inc c)) curr))
          (assoc o (vector r c) curr)
          o))

      (= r (dec nrows))
      (cond
        (= c 0)
        (if (and (> ((input (dec r)) c) curr)
                 (> ((input r) (inc c)) curr))
          (assoc o (vector r c) curr)
          o)

        (= c (dec ncols))
        (if (and (> ((input (dec r)) c) curr)
                 (> ((input r) (dec c)) curr))
          (assoc o (vector r c) curr)
          o)

        :else
        (if (and (> ((input (dec r)) c) curr)
                 (> ((input r) (dec c)) curr)
                 (> ((input r) (inc c)) curr))
          (assoc o (vector r c) curr)
          o))

      (= c 0)
      (if (and (> ((input (dec r)) c) curr)
               (> ((input r) (inc c)) curr)
               (> ((input (inc r)) c) curr))
        (assoc o (vector r c) curr)
        o)

      (= c (dec ncols))
      (if (and (> ((input (dec r)) c) curr)
               (> ((input r) (dec c)) curr)
               (> ((input (inc r)) c) curr))
        (assoc o (vector r c) curr)
        o)

      :else
      (if (and (> ((input (dec r)) c) curr)
               (> ((input r) (inc c)) curr)
               (> ((input r) (dec c)) curr)
               (> ((input (inc r)) c) curr))
        (assoc o (vector r c) curr)
        o))))



(def min-dict
  (loop [row 0
         col 0
         out {}]
    (cond
      (= row nrows)
      out

      (= col ncols)
      (recur (inc row) 0 out)

      :else
      (recur row (inc col) (check-height row col out)))))



;;
;;  this gets called only if r,c is not a minimum
;;  user provide search-list that has been scrubbed for corners/edges
;;
(defn find-lowest-neighbor [r c search-list]
  (let [neighbor-search-d (reduce #(let [rr (%2 0)
                                         cr (%2 1)
                                         m ((input (%2 0)) (%2 1))]
                                     (if (> (%1 :min) m)
                                       (assoc %1 :r rr, :c cr, :min m)
                                       %1))
                                  {:r -1, :c -1, :min 10}
                                  search-list)
        nextr (neighbor-search-d :r)
        nextc (neighbor-search-d :c)]
    (vector nextr nextc)))




;;
;;  accept the min-dict and populates
;;   its vals with puzzle "sizes" as
;;   accumulated recursively here
;;
(defn seek-min [r c d a]
  (let [curr ((input r) c)]
    (cond
      ;;  found a minimum, add in its size
      (contains? d (vector r c))
      (assoc d (vector r c) (+ a (d (vector r c))))

      (= r 0)
      (cond
        (= c 0)
        (let [[nextr nextc] (find-lowest-neighbor r c
                                                  (list
                                                    (vector (inc r) c)
                                                    (vector r (inc c))))]
          (seek-min nextr nextc d (inc a)))


        :else
        (let [[nextr nextc] (find-lowest-neighbor r c
                                                  (list
                                                    (vector (inc r) c)
                                                    (vector r (dec c))
                                                    (vector r (inc c))))]
          (seek-min nextr nextc d (inc a)))

      (= r (dec nrows))
      (cond
        (= c 0)
        (let [[nextr nextc] (find-lowest-neighbor r c
                                                  (list
                                                    (vector (dec r) c)
                                                    (vector r (inc c))))]
          (seek-min nextr nextc d (inc a)))

        (= c (dec ncols))
        (let [[nextr nextc] (find-lowest-neighbor r c
                                                  (list
                                                    (vector (dec r) c)
                                                    (vector r (dec c))))]
          (seek-min nextr nextc d (inc a)))

        :else
        (let [[nextr nextc] (find-lowest-neighbor r c
                                                  (list
                                                    (vector (dec r) c)
                                                    (vector r (inc c))
                                                    (vector r (dec c))))]
          (seek-min nextr nextc d (inc a)))

      (= c 0)
      (let [[nextr nextc] (find-lowest-neighbor r c
                                                (list
                                                  (vector (dec r) c)
                                                  (vector r (inc c))
                                                  (vector (inc r) c)))]
        (seek-min nextr nextc d (inc a)))

      (= c (dec ncols))
      (let [[nextr nextc] (find-lowest-neighbor r c
                                                (list
                                                  (vector (dec r) c)
                                                  (vector r (dec c))
                                                  (vector (inc r) c)))]
        (seek-min nextr nextc d (inc a)))

      :else
      (let [[nextr nextc] (find-lowest-neighbor r c
                                                (list
                                                  (vector (dec r) c)
                                                  (vector r (dec c))
                                                  (vector r (inc c))
                                                  (vector (inc r) c)))]
        (seek-min nextr nextc d (inc a))))))))



;;
;;  main
;;
(loop [row 0
       col 0
       out {}]
  (let [zeroed-min-dict (reduce #(let[[k _] %2] (assoc %1 k 0)) {} min-dict)]
    (cond
      (= row nrows)
      (println out)

      (= col ncols)
      (recur (inc row) 0 out)

      :else
      (recur row (inc col) (seek-min row col zeroed-min-dict #{})))))



